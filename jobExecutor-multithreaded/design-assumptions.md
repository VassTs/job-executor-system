## Εκπόνηση εργασίας:
Βασιλική Τσαντήλα

## Μεταγλώττιση και εκτέλεση:
```
make
terminal #1: ./bin/jobExecutorServer 2034 8 5
terminal #2: ./bin/jobCommander linux04.di.uoa.gr 2034 setConcurrency 2
````

## Σχεδιαστικές επιλογές
> Προκειμένου να κρατήσουμε τη δομή της 1ης εργασίας, ορίζουμε ο ενταμιευτής να είναι μια "ουρά" (που από πίσω είναι υλοποιήμενη με λίστα) "συγκεκριμένου μεγέθους". Με άλλα λόγια, αν ένας controller θέλει να εισάγει ένα job στην ουρά, τότε πρώτα τσεκάρει το μέγεθος της ουράς, και αν αυτό δεν ξεπερνάει το bufferSize (<- defined as a global variable), τότε έχει το ελεύθερο να προσθέσει ένα job στην ουρά.

> Όταν ο commander (ή ο server, αντίστοιχα) θέλουν να γράψουν x προτάσεις στο socket, τότε πρώτα στέλνουν τον αριθμό των προτάσεων που θέλουν να στείλουν. Στη συνέχεια, για κάθε πρόταση: στέλνουν πρώτα το πλήθος των χαρακτήρων από τους οποίους αποτελείται η πρόταση, και τέλος στέλνουν την ίδια την πρόταση.
Ο server (ή ο commander, αντίστοιχα) διαβάζει τα δεδομένα του socket γνωρίζοντας το πρωτόκολλο που ακολουθήθηκε για εγγραφή δεδομένων στο socket.

Ειδικότερα, για τα αποτελέσματα μιας issueJob εργασίας πρώτα στέλνεται το πλήθος των συνολικών χαρακτήρων που απαρτίζουν το αποτέλεσμα, ενώ στη συνέχεια το ίδιο το αποτέλεσμα στέλνεται ανά 200-αδες χαρακτήρων. Με ανάλογο, τρόπο ο commander διαβάζει τα αποτελέσματα της issueJob εργασίας.

> Ο commander καταλαβαίνει αν χρειάζεται να διαβάσει το αποτέλεσμα μιας issueJob εργασίας, ελέγχοντας αν η εντολή που έστειλε στον server είναι τύπου "issueJob".

> Στην issueJob, στην περίπτωση που το όνομα του job που δίνει ένας commander είναι πολύ μεγάλο (e.g. ls -l /usr/bin/* /usr/local/bin/* /bin/* /sbin/* /opt/* /etc/* /usr/sbin/*), τότε και στη συγκεκριμένη περίπτωση θα πρέπει να σπάσουμε το γράψιμο (και το διάβασμα, αντίστοιχα) του ονομάτος του job ανά 200-αδες χαρακτήρων. Στο συγκεκριμένο project, για λόγους μείωσης της πολυπλοκότητας του project επιλέγουμε να μην το κάνουμε. Ωστόσο, θα μπορούσε εύκολα να υλοποιηθεί με τον ίδιο ακριβώς τρόπο που υλοποιείται το "σπάσιμο" του αποτελέσματος μιας issueJob σε 200-αδες χαρακτήρων.

> Από εκφώνηση ξέρουμε ότι το αποτέλεσμα μιας issueJob εργασίας θα πρέπει να έχει την εξής μορφή:
-----jobID output start------
<έξοδος εργασίας>
-----jobID output end------

Όταν ένα <pid>.output είναι έτοιμο προς ανάγνωση από τον worker για αποστολή του περιεχομένου του στον αντίστοιχο jobCommander, τότε το worker thread:
1. Κάνει append στο τέλος του <pid>.output τη συμβολοσειρά: "-----jobID output end------"
2. Γράφει στο socket τη συμβολοσειρά "-----jobID output start------"
3. Διαβάζει το modified <pid>.output ανά 200 χαρακτήρες, και στέλνει 200-αδες χαρακτήρων στον jobCommander, μέχρι να φτάσει στο τέλος του αρχείου.

> Εφόσον ο server είναι να τερματίσει και υπάρχουν ακόμα controller threads που περιμένουν να βάλουν jobs στην ουρά, τότε σε κάθε commander των αντίστοιχων jobs στέλνουμε το μήνυμα: "SERVER TERMINATED BEFORE INSERTING TO BUFFER + EXECUTION".

> Όταν αφαιρούμε μέσω stop ένα <job> που βρίσκεται στον ενταμιευτή, τότε στέλνουμε στον commander που υπέβαλε το <job> το εξής μήνυμα: "Your job was removed from buffer before execution by a different commander".

> Όταν ένας controller thread διαβάζει τον τύπο εντολής "exit" από έναν commander, τότε ο controller στέλνει το σήμα SIGUSR1 στο process του server (δηλαδή, στον εαυτό του) προκειμένου να ξεμπλοκάρει η accept του main thread. Μόλις ξεμπλοκάρει η accept, το main thread περιμένει όλους τους controllers και τα worker threads να τελειώσουν. Στη συνέχεια τερματίζει και το main thread.

> Ο τρόπος με τον οποίο ξέρω πόσα worker threads τρέχουν ανά πάσα στιγμή είναι ο εξής:
Έχω μια global μεταβλητή global_Running την οποία με χρήση κατάλληλου mutex (global_Mtx_Running) ένας worker thread αυξάνει κατά 1, όταν είναι να εκτελέσει ένα job (ενώ αντίστοιχα ένας worker thread την μειώνει κατά 1, όταν έχει εκτελέσει πλήρως ενός job).
Με χρήση της global_Running και της τιμής του global_Concurrency, μπορώ να αποφασίσω αν ένας worker μπορεί να τρέξει ή όχι (εφόσον υπάρχει κάποιο job στην ουρά).

> Δεδομένων των τιμών global_Running, global_Concurrency ένας worker thread ελέγχει αν μπορεί να τρέξει. Αν δεν μπορεί να τρέξει, περιμένει (δηλαδή, κάνει wait σε condition variable) μέχρι να μπορεί να τρέξει. Αν μπορεί να τρέξει, τότε κάνει global_Running++ δεσμεύοντας έτσι 1 slot στα running workers.
Όταν πάρει το οκευ από τις global_Running, global_Concurrency ότι μπορεί να τρέξει, τότε ελέγχει αν υπάρχει κάτι στην ουρά. Αν δεν υπάρχει, τότε περιμένει (δηλαδή, κάνει wait σε άλλο condition variable) μέχρι να μπορεί να τρέξει.

Η εκφώνηση προτείνει ένας worker thread να ξυπνά όταν υπάρχει κάτι στην ουρά. Στη συνέχεια, ο worker να πηγαίνει και να ελέγχει αν το τρέχον concurrency level του επιτρέπει να τρέξει. 
Στο σημείο αυτό, όμως, ο worker πρέπει να ξανά ελέγξει αν υπάρχει κάτι στην ουρά, πριν προχωρήσει σε εκτέλεση κάποιου job.
Παρατηρούμε, δηλαδή, ότι θα χρειαστεί διπλός έλεγχος της ουράς από τον worker, κάτι το οποίο δεν χρειάζεται να γίνει με τον τρόπο που προτείνουμε στην ακριβώς προηγούμενη πρόταση. Επιλέξαμε δηλαδή, τον συγκεκριμένο τρόπο, καθώς φαίνεται στην πράξη ότι είναι σημαντικά πιο αποδοτικός.
