## Εκπόνηση εργασίας:
Βασιλική Τσαντήλα

## Μεταγλώττιση και εκτέλεση:
```
make quick
./scripts/test_jobExecutor_1.sh
````

## Επισημάνσεις αναφορικά με την εκτέλεση των tests:
Tests που περιλαμβάνουν την εκτέλεση του προγράμματος `progDelay` έχει προστεθεί το πρόθεμα `./bin/progDelay`.
Αντίστοιχα, αν θέλουμε ο jobExecutorServer να εκτελέσει ένα δικό μας πρόγραμμα, θα πρέπει να του το ζητήσουμε ως:
./bin/jobCommander issueJob ./<πρόγραμμα> <args_1> ... <args_N> και όχι ./bin/jobCommander issueJob <πρόγραμμα> <args_1> ... <args_N> 

Τα .txt αρχεία που δίνονται ως παράμετρο στο multijob.sh θα πρέπει να τελειώνουν με μία κενή γραμμή. Διαφορετικά, η τελευταία γραμμή του .txt δεν θα διαβαστεί από το script.

Πριν από την εκτέλεση οποιουδήποτε script (test ή μη) θα πρέπει να γίνεται εκ νέου μεταγλώττιση (`make quick`).


## Σχεδιαστικές επιλογές
> Ο κάθε Commander ανοίγει 2 pipes με ονόματα: pid_w και pid_r, (w = write, r = read) όπου <pid> το pid του Commander 
Επιπλέον ανοίγει το pipe με όνομα: server.pipe το οποίο το δημιουργεί ο server.
Στο server.pipe κάθε Commander γράφει το pid του.
Έτσι, γίνεται γνωστό στον server ποια είναι τα pipes του Commander, τα οποία χρειάζεται και εκείνος να ανοίξει (pid_w και pid_r)

> Όταν ο commander (ή ο server, αντίστοιχα) θέλουν να γράψουν x προτάσεις στο pipe, τότε πρώτα στέλνουν τον αριθμό των προτάσεων που θέλουν να στείλουν. Στη συνέχεια, για κάθε πρόταση: στέλνουν πρώτα το πλήθος των χαρακτήρων από τους οποίους αποτελείται η πρόταση, και τέλος στέλνουν την ίδια την πρόταση.
Ο server (ή ο commander, αντίστοιχα) διαβάζει τα δεδομένα του pipe γνωρίζοντας το πρωτόκολλο που ακολουθήθηκε για εγγραφή δεδομένων στο pipe.

> Τα read άκρα των pipes του server φροντίζουμε να τα ανοίγουμε σε blocking mode (ώστε να λειτουργεί η select). Ο τρόπος που ελέγχουμε αν στο εκάστοτε pipe υπάρχει κάτι για διάβασμα, είναι μέσω της select. Με αυτόν τον τρόπο, καταφέρνουμε ο server να μένει αδρανής, όταν δεν υπάρχει κάποιο δεδομένο για διάβασμα σε τουλάχιστον ένα από τα ανοιχτά pipes του server. Εν συνεχεία, μέσω της FD_ISSET βρίσκουμε ποιο(α) file descriptor(s) έκαναν την select να ξεμπλοκάρει.

> Ο server πριν κάνει exit, σκοτώνει με kill όλα τα running jobs

> Όταν ένα παιδί του server τερματίζει, τότε καλείται ο signal handler που ορίσαμε για τον διαχειρισμό του σήματος SIGCHLD.
Ο signal handler ελέγχει αν τερμάτισε κάποιο επιπλέον παιδί (stack of SIGCHLD).
Ο signal handler αφαιρεί από την ουρά/vector με τα running jobs, τα jobs που τερμάτισαν.
Η εισαγωγή νέων εργασιών στην ουρά/vector με τα running jobs δεν θα γίνει εντός του signal handler, αλλά στο τελευταίο μέρος του while του server.

> Όταν αφαιρείται ένα job από την ουρά που φυλλάσει τα queued jobs, τότε η θέση των jobs που παραμένουν στην ουρά ανανέονται.
Π.χ. 
queue = job3, job2, job1 (με θέσεις: 3,2 και 1 αντίστοιχα)
stop job1;
queue = job3, job2 (με θέσεις 2 και 1, αντίστοιχα)

> Η "ουρά" που φυλλάσει τα running jobs, εν προκειμένω είναι ένα vector το οποίο το διαχειριζόμαστε ως ουρά.
Όταν, λοιπόν, κάποιος μάς ζητήσει `poll running`, τότε οι θέσεις των running jobs, θα είναι οι θέσεις που έχουν τα jobs μέσα στην "ουρά"/vector.
Π.χ.
vector = job1 (με θέση: 1)
run job3;
vector = job3, job1 (με θέσεις: 2 και 1, αντίστοιχα)

